<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>WebGl Ray-Tracing</title>
        <link rel="stylesheet" href="./css/stylesheet.css">
            <script type="text/javascript" src="./js/gl-matrix.js"></script>
            <script type="text/javascript" src="./js/webgl-debug.js"></script>
            <script type="text/javascript" src="./js/webgl-utils.js"></script>
            <script type="text/javascript" src="./js/rayTracing.js"></script>

            <!-- vertex shader -->
            <script id="shader-vs" type="x-shader/x-vertex">
                attribute vec3 aVertexPosition;
                uniform mat4 uPMatrix;

                void main(void) {
                    gl_Position = uPMatrix * vec4(aVertexPosition, 1.0);
                }
            </script>
                <!-- fragment shader -->
            <script id="shader-fs" type="x-shader/x-fragment">
                precision mediump float;

                uniform mat3 uRepMatrix;
                uniform float uAlpha;
                uniform float uTimeSinceStart;
                uniform mat4 uMVMatrix;

                vec3 uDir;
                vec3 uOri =  vec3(0.0,0.0,2.0);

                const float rebond = 4.0;

                float uSphereRayon = 0.25;
                uniform vec3 uSpherePos;// = vec3(0.0,0.8,0.0);

                vec3 uBoxMin = vec3(-1.0, -1.0, -1.0);
                vec3 uBoxMax = vec3(1.0, 1.0, 1.0);

                vec3 uLightPos = vec3(0.5, 0.5, 0.5);

                vec3 normalForSphere(vec3 hit, vec3 spherePosition, float sphereRayon) {
                    return (hit - spherePosition) / sphereRayon;
                }

                float intersectSphere( vec3 dir, vec3 origin, vec3 spherePosition, float sphereRayon) {
                    vec3 l = origin - spherePosition;
                    float a = dot(dir, dir);
                    float b = 2.0 * dot(l, dir);
                    float c = dot(l, l) - sphereRayon*sphereRayon;
                    float discriminant = b*b - 4.0*c*a;
                    if(discriminant > 0.0) {
                        float t = (-b-sqrt(discriminant))/(2.0*a);
                        if(t > 0.0){
                            return t;
                        }
                    }
                    return 10000.0;
                }

                float intersectionCube( vec3 dir, vec3 origin, vec3 cubeMin, vec3 cubeMax) {
                    vec3 tMin = (cubeMin - origin) / dir;
                    vec3 tMax = (cubeMax - origin) / dir;
                    vec3 t1 = min(tMin, tMax);
                    vec3 t2 = max(tMin, tMax);
                    float tNear = max(max(t1.x, t1.y), t1.z);
                    float tFar = min(min(t2.x, t2.y), t2.z);
                    return (tNear >= tFar) ? tNear : tFar;
                }

                vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
                    vec3 normal = vec3(0.0, 0.0, 0.0);
                    if(hit.x < cubeMin.x + 0.00001){
                        normal = vec3(-1.0, 0.0, 0.0);
                    }else if (hit.x > cubeMax.x - 0.00001){
                        normal = vec3(1.0, 0.0, 0.0);
                    }
                    else if(hit.y < cubeMin.y + 0.00001){
                        normal = vec3(0.0, -1.0, 0.0);
                    }else if (hit.y > cubeMax.y - 0.00001){
                        normal = vec3(0.0, 1.0, 0.0);
                    }
                    else if(hit.z < cubeMin.z + 0.00001){
                        normal = vec3(0.0, 0.0, -1.0);
                    }else if (hit.z > cubeMax.z - 0.00001){
                        normal = vec3(0.0, 0.0, 1.0);
                    }
                    return normal;
                }

                float shadow(vec3 origin, vec3 dir) {

                        float tSphere = intersectSphere( dir , origin, uSpherePos, uSphereRayon);
                        float tLight = intersectSphere( dir , origin, uLightPos, 0.1);
                        if ( tSphere < tLight){
                            return 0.0;
                        }else{
                            return 1.0;
                        }
                }

                float random(vec3 scale, float seed) {
                    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
                }

                vec3 cosineWeightedDirection(float seed, vec3 normal) {
                    float u = random(vec3(13.9898, 0.233, 151.7182), seed);
                    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
                    float r = sqrt(u);
                    float angle = 6.283185307179586 * v;
                    vec3 sdir, tdir;
                    if (abs(normal.x) < .5) {
                        sdir = cross(normal, vec3(1, 0, 0));
                    } else {
                        sdir = cross(normal, vec3(0, 1, 0));
                    }
                    tdir = cross(normal, sdir);
                    return r * cos(angle) * sdir + r * sin(angle) * tdir + sqrt(1. - u) * normal;
                }

                vec3 uniformSampleHemisphere(float r1,float r2) {
                    float sinTheta = sqrt(1.0 - r1 * r1);
                    float phi = 6.283185307179586 * r2;
                    float x = sinTheta * cos(phi);
                    float z = sinTheta * sin(phi);
                    return vec3(x, r1, z);
                }

                vec3 uniformlyRandomDirection(float seed) {
                    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
                    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
                    float z = 1.0 - 2.0 * u;
                    float r = sqrt(1.0 - z * z);
                    float angle = 6.283185307179586 * v;
                    return vec3(r * cos(angle), r * sin(angle), z);
                }

                vec3 uniformlyRandomVector(float seed) {
                    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
                }

                /*vec3 rayDirection(vec3 normal, float seed) {

                    return sampleWorld;
                }*/

                highp float rand(vec2 co)
                {
                    highp float a = 12.9898;
                    highp float b = 78.233;
                    highp float c = 43758.5453;
                    highp float dt= dot(co.xy ,vec2(a,b));
                    highp float sn= mod(dt,3.14);
                    return fract(sin(sn) * c);
                }

                vec3 raytrace(vec3 dir, vec3 origin){
                    vec3 aColor = vec3(0.0);
                    vec3 colorMask = vec3(1.0);
                    vec3 directColor;
                    vec3 indirectColor;
                    for(float i=1.0; i<rebond+2.0; i+=1.0){
                        //On calcul tout les intersection posible avec les objects de la scene
                        float tBox = intersectionCube(dir,origin, uBoxMin, uBoxMax);
                        float tsphere = intersectSphere(dir,origin,uSpherePos,uSphereRayon);

                        //On test si le quel est le point d'intersection visible
                        float t = 10000.0;
                        if (tBox < t){
                             t = tBox;
                        }
                        if(tsphere < t){
                            t = tsphere;
                        }


                        vec3 hit = origin + dir * t;
                        vec3 surfaceColor = vec3(0.75);
                        float specularHighlight = 0.0;
                        //On calcule la normal au point d'intersection
                        vec3 normal;

                        if (t == tBox) {
                               normal = -normalForCube(hit, uBoxMin, uBoxMax);
                               if (hit.x < uBoxMin.x + 0.00001){
                                    surfaceColor = vec3(0.2, 1.0, 0.2);
                               }
                               else if (hit.x > uBoxMax.x - 0.00001){
                                    surfaceColor = vec3(1.0, 0.1, 0.1);
                               }
                        }
                        if (t == tsphere){
                            normal = normalForSphere(hit, uSpherePos, uSphereRayon);
                        }

                        vec3 lightToHit = normalize(uLightPos - hit);
                        float diffuse = max(0.0, dot(lightToHit, normal));
                        float shadowIntensity = shadow(hit + normal*0.00001, lightToHit);

                        /*colorMask *= surfaceColor;
                        aColor += colorMask * (0.5 * diffuse * shadowIntensity);
                        aColor += colorMask * specularHighlight * shadowIntensity;*/



                        vec3 Nt, Nb;
                        float r = sqrt(normal.x * normal.x + normal.z * normal.z + normal.y * normal.y );
                        if(abs(normal.x) >  abs(normal.y)){
                            Nt = vec3(normal.z,0.0,-normal.x) / r ;
                        }else{
                            Nt = vec3(0.0,-normal.z,normal.y) / r ;
                        }

                        Nb = cross(normal, Nt);

                        float r1 = rand(gl_FragCoord.xy);
                        float r2 = rand(gl_FragCoord.yx);


                        vec3 sampleRand = uniformSampleHemisphere(r1,r2);
                        dir =  vec3(
                            sampleRand.x * Nb.x + sampleRand.y * normal.x + sampleRand.z * Nt.x,
                            sampleRand.x * Nb.y + sampleRand.y * normal.y + sampleRand.z * Nt.y,
                            sampleRand.x * Nb.z + sampleRand.y * normal.z + sampleRand.z * Nt.z);


                        if(i == 1.0){
                            directColor = shadowIntensity * surfaceColor* diffuse;
                        }else{
                            indirectColor += 0.5*(surfaceColor * diffuse * shadowIntensity*1.0/i);
                        }

                        /*colorMask *= surfaceColor;
                        aColor += colorMask  * diffuse * shadowIntensity*1.0/(2.0*float(i));*/

                        origin=hit;
                    }
                    //return aColor;
                    return directColor + indirectColor;
                }

                void main(void) {
                    vec3 pixelScreen = uRepMatrix*vec3(gl_FragCoord.x,gl_FragCoord.y,1.0);
                    vec3 pixelCamera = pixelScreen*vec3(uAlpha,uAlpha,-1.0);
                    uDir = normalize(pixelCamera);
                    vec3 color = raytrace(vec3(vec4(uDir,0)*uMVMatrix),vec3(vec4(uOri,0)*uMVMatrix));
                    gl_FragColor = vec4(color,1.0);
                }
            </script>
    </head>
    <body>
      <h1>WebGl Ray-Tracing</h1>
      <p>
        Canvas pour cr√©er une application WebGL.
      </p>
      <div id="main">
        <canvas id="glcanvas" width="512" height="512"></canvas>
        <div id="error"><noscript>Please enable JavaScript.</noscript></div>
        <h2>Interaction</h2>
          <p>
            <button type="button" name="button" onclick="">Click Me!</button>
          </p>
      </div>
  </body>

</html>
